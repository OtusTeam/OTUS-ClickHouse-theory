## 1. Материализованные представления (MV)

### 1.1. Целевые таблицы

При создании материализованного представления необходимо определить целевую таблицу одним из двух способов: явным или неявным.

*   **Неявное указание (`ENGINE = engine`)**:
    *   Таблица-приемник создается автоматически.
    *   Имеет префикс `.inner_id` и постфикс в виде UUID, указывающего на представление, которому она принадлежит.
*   **Явное указание (`TO [db.]table`)**:
    *   Таблица-приемник должна быть создана заранее.
    *   При использовании этого способа **нельзя** указывать `POPULATE`.

**Свойства в зависимости от типа таблицы:**

*   **С явными таблицами (`TO ...`)**:
    *   `POPULATE` не поддерживается.
    *   Команда `DROP VIEW` не удаляет таблицу, указанную в `TO`.
*   **С неявными таблицами (`.inner.*`)**:
    *   `POPULATE` поддерживается.
    *   Команда `DROP VIEW` удаляет внутреннюю таблицу `.inner.UUID`.

### 1.2. Опция POPULATE

*   Если указано `POPULATE`, при создании представления в него добавляются все данные, уже существующие в исходной таблице на момент создания.
*   Если `POPULATE` **не** указано, представление будет содержать только данные, добавленные в исходную таблицу после его создания.
*   **Рекомендация:** Использовать `POPULATE` не рекомендуется из-за проблем:
    1.  **Большое использование памяти** в момент создания.
    2.  **Пропуск данных**, которые добавляются в исходную таблицу во время процесса заполнения представления.

### 1.3. Стратегии заполнения целевой таблицы без POPULATE

В документе описаны три подхода для безопасного заполнения MV старыми данными, избегая проблем `POPULATE`.

**Способ 1: Условная фильтрация**
1.  Создать MV с условием в `WHERE`, которое сработает только для будущих данных (например, фильтр по дате или возрастающему ID).
2.  Дождаться, когда новые данные начнут поступать в целевую таблицу.
3.  С помощью `INSERT ... SELECT` перенести старые записи напрямую из источника в целевую таблицу.

**Способ 2: Блокировка записи и снепшот**
1.  Остановить запись в исходную таблицу (например, с помощью `CONSTRAINT write_lock CHECK false` или на уровне приложения).
2.  Сделать `FREEZE` (снепшот) таблицы или партиции.
3.  Создать MV.
4.  Разрешить `INSERT`-ы обратно.
5.  Создать временную таблицу из снепшота.
6.  С помощью `INSERT ... SELECT` перенести старые записи из временной таблицы в целевую таблицу MV.

**Способ 3: Использование материализованного столбца-переключателя**
1.  Добавить в исходную таблицу материализованный столбец: `mv_switch_column Bool MATERIALIZED false`.
2.  Создать MV с условием `WHERE (...) AND mv_switch_column`.
3.  Изменить дефолтное значение столбца на `true`: `MODIFY COLUMN mv_switch_column Bool MATERIALIZED true`. Теперь все новые вставки будут попадать в MV.
4.  Вставить старые данные в целевые таблицы MV, где столбец все еще `false`: `INSERT INTO MV SELECT ... FROM ... WHERE (...) AND not mv_switch_column`.
5.  Убрать условие на `mv_switch_column` из запроса MV: `ALTER TABLE MV MODIFY QUERY ...`.
6.  Удалить вспомогательный столбец из исходной таблицы: `ALTER TABLE DROP mv_switch_column`.

### 1.4. Модификация MV

**Legacy-подходы (до появления `MODIFY QUERY`)**

*   **С явным таргетом:**
    1.  Остановить запись в исходную таблицу.
    2.  Удалить MV.
    3.  Внести изменения в исходную таблицу.
    4.  Внести изменения в таргетную таблицу (возможно, потребуется очистка и наполнение заново).
    5.  Пересоздать MV с новыми полями.
    6.  Запустить запись в исходную таблицу.
*   **С неявным таргетом:**
    1.  Остановить запись в исходную таблицу.
    2.  Отсоединить внутреннюю таблицу: `DETACH TABLE .inner_id.UUID`.
    3.  Сохранить UUID (из `SHOW CREATE TABLE <MV>`).
    4.  Удалить MV: `DROP VIEW`.
    5.  Внести изменения в исходную таблицу.
    6.  Присоединить обратно внутреннюю таблицу: `ATTACH TABLE .inner_id.UUID`.
    7.  Внести изменения в таргетную таблицу.
    8.  Присоединить MV обратно: `ATTACH MATERIALIZED VIEW`.

**Современный подход: `ALTER TABLE ... MODIFY QUERY`**

*   Позволяет изменить `SELECT` внутри MV "на ходу".
*   **Не меняет** структуру исходной таблицы.
*   **Не меняет** структуру целевой таблицы.
*   Работает как для явных, так и для неявных целевых таблиц.

### 1.5. Важные замечания по MV

*   **Ключ сортировки:** Ключ сортировки таблицы-приемника должен соответствовать набору группируемых полей в запросе преобразования.
*   **Функции `State`:** При сохранении данных в таблицы с движком `AggregatingMergeTree` необходимо использовать модификатор `State` в агрегирующих функциях (например, `countState`).
*   **Независимость:** MV ничего не знает про движки (`Summing`, `Aggregating`, `Collapsing`) в исходной таблице. MV также ничего не знает про изменения структур исходной и целевой таблиц.

### 1.6. Маршрутизация и каскады

*   MV можно использовать для:
    *   **Фильтрации** входных данных.
    *   **Раскладки** данных в разные целевые таблицы в зависимости от условий.
*   **`parallel_view_processing`**: Настройка, обеспечивающая параллельную отправку записей в приаттаченные представления. По умолчанию `0` (последовательная запись). Не влияет на каскадные MV.
*   **Каскадные MV**: Поддерживается возможность создавать каскадные материализованные представления (когда одно MV является источником для другого), а также несколько представлений на одну таблицу-источник.

### 1.7. MV и JOIN

*   В запросе MV возможно использовать `JOIN`, `joinGet`, словари.
*   **Минус:** Это замедляет вставку в целевую таблицу, так как MV следит за вставками только одного источника.

### 1.8. Когда использовать MV

*   Маршрутизация данных из одного или нескольких источников в один или несколько целевых таблиц.
*   Сложные каскадные Data Pipeline'ы.
*   Требуется обогащение или трансформация данных (в том числе с помощью `JOIN`).
*   **Важно:** Если требуется просто агрегация, лучше использовать проекции.

---

## 2. Проекции

### 2.1. Что такое проекции

*   Проекции хранятся в директории куска данных исходной таблицы в виде подкаталога с анонимным куском таблицы `MergeTree`.
*   **Движок:** Если в определении проекции есть секция `GROUP BY`, то для её хранения используется движок `AggregatingMergeTree`, а агрегатные функции преобразуются в тип `AggregateFunction`.
*   **Ключ сортировки:** Если в проекции есть секция `ORDER BY`, она используется как первичный ключ для данных проекции.
*   **Слияние:** Во время слияния кусков основной таблицы, куски данных проекции также объединяются.

### 2.2. Когда используются проекции

Проекции автоматически используются оптимизатором запросов, если выполнены все условия:
1.  Запрос `SELECT` соответствует запросу, определенному в проекции.
2.  Включена настройка `optimize_use_projections = 1`.
3.  Количество выбранных строк из проекции меньше общего количества строк в таблице.

### 2.3. Настройки использования проекций

*   **`optimize_use_projections`**:
    *   `0` — Проекции не поддерживаются (отключены).
    *   `1` — Проекции поддерживаются (включены).
    *   Значение по умолчанию: `0`.
*   **`force_optimize_projection`**:
    *   `0` — Проекции используются опционально (по возможности).
    *   `1` — Проекции **обязательно** используются. Если оптимизатор не может использовать проекцию, запрос может завершиться ошибкой.
    *   Значение по умолчанию: `0`.

### 2.4. Информация о проекциях

Для мониторинга и отладки проекций существуют системные таблицы:

*   **`system.projection_parts`**: Содержит информацию о кусках данных проекций. Похожа на `system.parts`, но имеет поля с префиксом `parent*`, указывающие на родительские куски основной таблицы.
*   **`system.projection_parts_columns`**: Позволяет посмотреть поля запроса проекции и их типы.

**Примеры запросов:**
```sql
-- Проверить куски основной таблицы
SELECT name, active FROM system.parts WHERE table='tbl_with_projection';

-- Проверить куски проекции
SELECT name, parent_name, rows, active FROM system.projection_parts WHERE table='tbl_with_projection';

-- Проверить типы полей проекции
SELECT column, type, column_position FROM system.projection_parts_columns;
```

### 2.5. Управление проекциями

*   **`ADD PROJECTION`** — добавляет описание проекции в метаданные таблицы, но **не заполняет** её данными.
*   **`DROP PROJECTION`** — удаляет описание проекции из метаданных и удаляет файлы проекции с диска.
*   **`CLEAR PROJECTION`** — удаляет файлы проекции с диска, но **сохраняет** её описание в метаданных.
*   **`MATERIALIZE PROJECTION`** — заполняет проекцию данными в указанной таблице или партиции. Используется после `ADD PROJECTION` для создания данных.
