## MergeTree

### Алгоритм
- MergeTree — алгоритм объединения данных, вставленных частями.
- Новые данные при добавлении на хранение добавляются блоками.
- Блоки объединяются в фоновом режиме в более крупные блоки.
- В ClickHouse такой блок называется **Part**.
- Объединение называется **Merge**.
- Концепция визуально напоминает дерево.

### Реализация
1. Данные поступают на вход парсера ClickHouse.
2. Данные нарезаются на блоки и сортируются по Primary Key.
3. Данные сохраняются в таблице отсортированными блоками — такие блоки называются **Part**.
4. Фоном происходит объединение блоков (Merge), объединяемые Part-ы также сортируются между собой в новый Part.

### Структура Part
#### Именование
Примеры:
- `20240101_1_1_0` — Part, образованный самым первым блоком, поступившим в таблицу.
- `20240101_1_2_1` — Part, полученный слиянием Part-ов `20240101_1_1_0` и `20240101_2_2_0`.
- Part, полученный в результате 18 слияний разных партов с 1012 номера блока по 7238.

**Компоненты имени Part:**
- **PARTITION ID** — строковое представление значения ключа партиционирования.
- **min_block** — порядковый номер блока, для каждого нового блока уникальный.
- **max_block** — изначально равен min_block, после слияний будет номером максимального блока, участвовавшего в слиянии.
- **level** — количество слияний, произошедшее для образования Part-а.

#### Содержание Part
- **primary.idx** — хранит значение Primary Key для каждой «засечки» — адреса на диске в файле data.bin для колонки.
- **data.mrk3** — хранит сами «засечки», т.е. номер засечки и адрес в файле data.bin, для каждой колонки, для каждой гранулы.
- **data.bin** — хранит сами данные колонок.

---

## Primary Key — minmax index
- Основная задача индекса — эффективная выборка данных, прочитать с диска только те данные, которые были запрошены.
- Индексы постоянно держатся в оперативной памяти.
- В ClickHouse классические индексы, в силу объема данных, не применимы. Хранение значения Primary Key для каждой строки может занимать сотни гигабайт в оперативной памяти.
- В ClickHouse применяется **разряженный индекс** (minmax индекс, sparse индекс).
- Индексы позволяют выбирать не конкретные строки, а **гранулы** по `index_granularity` строк.

### Primary Key и гранулярность — разреженный индекс
- Значения хранятся гранулами по `index_granularity` строк.
- Для каждой гранулы каждого столбца есть засечка с адресом на диске.
- Для каждой засечки хранится значение Primary Key.

---

## Partition Key
- Partition Key — логическое ограничение на Merge Part-ов.
- Part-ы с разным Partition Key не объединяются.
- Используется для массового удаления данных.
- В ClickHouse точечное удаление реализовано как мутация всего Part-а, поэтому удобно ограничить Merge партов логической границей, чтобы удалять данные целыми партами, соответствующей конкретному значению Partition Key.
- ClickHouse умеет выполнять поиск по Partition Key, однако список функций не документирован, и поведение меняется от версии к версии. **Не следует использовать Partition Key в качестве индекса, для этого существует Primary Key.**

---

## Типы данных

### Строковые
- **String** — размер не ограничен, можно писать произвольные данные, включая нулевые байты.
- **FixedString(N)** — размер ограничивается N байт (не символов), недостающие байты заполняются нулевыми байтами (`\0`). Примеры использования: `FixedString(16)` для MD5, `FixedString(32)` для SHA256.

### Числовые
- **Беззнаковые целые**: `UInt8`, `UInt16`, `UInt32`, `UInt64`, `UInt256`. Диапазон: `0 .. 2^N-1`.
- **Знаковые целые**: `Int8`, `Int16`, `Int32`, `Int64`, `Int128`, `Int256`. Диапазон: `-2^(N-1) .. 2^(N-1)-1`.
- **Числа с плавающей запятой**: `Float32`, `Float64` (аналоги `float` и `double` из языка C).
- **Десятичные**: `Decimal(P, S)` — знаковые дробные. При делении лишние знаки отбрасываются (не округляются).
  - **P** — сколько всего знаков.
  - **S** — сколько из них дробных.
  - **Алиасы**: `Decimal32(S)` для P=1..9, `Decimal64(S)` для P=10..18, `Decimal128(S)` для P=19..38, `Decimal256(S)` для P=39..76.
  - **Диапазон**: `-1 * 10^(P - S) .. 1 * 10^(P - S)`.

### Bool и Enum
- **Bool** — хранится как `UInt8`, принимает значения `0` и `1`. Можно вставлять строки `'false'` и `'true'`.
- **Enum** и **Enum16** — хранится как `Int8` или `Int16` (для Enum16). Пример объявления:  
  `user_type Enum('admin' = -128, 'user' = 0, 'moderator' = 1, 'author' = 127)`.  
  Можно вставлять строками согласно объявлению типа или числами (нет проверки на корректность).

### Дата и время
- **Date** и **Date32** — хранятся как `UInt16` и `UInt32`.
  - **Диапазоны**:  
    Date: `1970-01-01 .. 2149-06-06`.  
    Date32: `1900-01-01 .. 2299-12-31`.
  - **Формат вставки**: `String '\d\d\d\d-\m\m-\d\d'`.
- **DateTime(timezone)** и **DateTime64(timezone, precision)** — хранятся как `UInt32` и `UInt64`.
  - **Диапазоны**:  
    DateTime: `1970-01-01 00:00:00 .. 2106-02-07 06:28:15`.  
    DateTime64 зависит от precision.
  - **Формат вставки**: `String '\d\d\d\d-\m\m-\d\d \H:\H:\M:\M:\S:\S.[0..9]+'`. Можно вставлять как `UInt32`/`UInt64` (интерпретируется как Unix timestamp в UTC).
  - **timezone** — не обязательный параметр, по умолчанию выбирается из конфигурационного файла.
  - **precision** — сколько знаков после точки для долей секунды.

### Структуры
- **Array(T)** — массив элементов типа T. Пример: `SELECT toTypeName([1, 2, 3])` вернет `Array(UInt8)`. Выбор элемента N: `[...][N]` (нумерация с 1).
- **Tuple(T1, T2, ...)** — кортеж любых элементов. Пример: `SELECT toTypeName([1, 2, 3])` вернет `Tuple(UInt8, UInt8, UInt8)`. Выбор элемента N: `(...).N` (нумерация с 1).
- **Именованный Tuple(a T1, b T2, ...)** — можно объявлять при создании таблицы. Пример: `dsp_info Tuple(name String, id UInt16)`. Выбор элемента по имени: `dsp_info.name`.
- **Map(T1, T2, ...)** — пары ключ-значение, хранит несколько пар. Пример:  
  `SELECT toTypeName(CAST(arrayMap((x, y) -> (x, y), ['k1', 'k2'], [1, 2]), 'Map(String,UInt64)'))` вернет `Map(String, UInt64)`. Выбор элемента по ключу: `map_column['key']`.

---

## Специальные типы данных

### Nested
- Вложенный тип данных.
- Объявляется при создании таблицы:  
  `( a String, b Nested ( id UInt32, name String ), c DateTime )`.
- Раскрывается как: `( a String, b.id Array(UInt32), b.name Array(String), c DateTime )`.

### Расширенные типы данных
- Основаны на базовых, поддерживают дополнительные функции.
- **Point** — основан на `Tuple(Float64, Float64)`, применяется для географических данных.
- **IPv4** — основан на `UInt32`, поддерживаются функции работы с IP-адресами.
- **IPv6** — основан на `FixedString(16)`, аналогично.
- **JSON** — хранится как динамически меняющийся Named Tuple, вставляется как String. Для корректного отображения нужна настройка `output_format_json_named_tuples_as_objects = 1`.

### AggregateFunction(function, Type)
- Применяется для сохранения промежуточных результатов агрегации в материализованных представлениях.
- Нельзя объявить явным образом. Можно объявить при создании таблицы.
- Можно получить, добавив суффикс `-State` к агрегационной функции. Пример:  
  `SELECT uniqState(column) FROM table` — сохраняет промежуточный результат функции `uniq`.
- Для получения итогового результата используется суффикс `-Merge`. Пример:  
  `SELECT uniqMerge(MyAggFunc) FROM (SELECT uniqState(column) AS MyAggFunc FROM ...)`.

### Interval
- Используется для упрощения выполнения арифметических операций с датой и временем.
- Объявляется как `INTERVAL N UNIT`, где:
  - **N** — количество.
  - **UNIT** — единица времени (`NANOSECOND`, `MICROSECOND`, `MILLISECOND`, `SECOND`, `MINUTE`, `HOUR`, `DAY`, `WEEK`, `MONTH`, `QUARTER`, `YEAR`).
- Пример: `INTERVAL 2 DAY`.

### Алиасы для типов данных
- Используются для взаимодействия с другими системами (например, MySQL).
- Примеры алиасов: `VARCHAR`, `MEDIUMBLOB`, `CHAR` — алиасы для `String`; `BIGINT` — алиас для `Int64`; `SMALLINT` — алиас для `Int16`.
- Список трансляций можно найти в таблице `system.data_type_families`.

---

## Рефлексия (проверка достижения целей)

### Вопросы для проверки
1. Какой тип данных вы выберете для хранения SHA256 от пароля пользователя?
2. Какие поля из предложенных вы включите в индекс: `date (Date)`, `timestamp (DateTime)`, `response_body (String)`, `response_time_ms (UInt16)`? В каком порядке вы включите эти поля? Можно приводить свои примеры.

---
