## 1. Словари

### Определение
Словарь — данные из внешних систем, которые регулярно забираются ClickHouse-ом в оперативную память (как правило, но не только) для использования совместно с собственными данными в запросах.

### Структура словаря
Словарь представляет собой KEY-value хранилище. Ключ может быть простым или составным. При обращении к словарю ключ указывается целиком. Атрибутов может быть от 1 и больше, их значения можно получать по ключу.

### Зачем нужны словари
1. **Мутабельные данные**  
   ClickHouse хранит неизменяемые события (действия пользователя). Изменяемые свойства пользователя (статус активности, баланс и др.) не подходят для хранения в ClickHouse, но могут использоваться через словари.

2. **Интеграции с другими системами**  
   Мутабельные данные часто хранятся в других системах. Словари позволяют интегрировать эти данные с данными ClickHouse.

3. **Производительная альтернатива JOIN**  
   Даже если данные уже в ClickHouse, но в разных таблицах, построение словаря вокруг меньшей таблицы или её агрегата — более производительное решение, особенно при работе с миллионами и миллиардами строк.

### Создание словаря

#### Конфигурация
- **XML-конфигурация**:  
  ```xml
  <dictionary>
    <name>ИМЯ СЛОВАРЯ</name>
    <structure>КЛЮЧ И АТРИБУТЫ</structure>
    <source>ИСТОЧНИК</source>
    <layout>СХЕМА ХРАНЕНИЯ (ОБЫЧНО В ПАМЯТИ)</layout>
    <lifetime>КАК ЧАСТО ОБНОВЛЯТЬ</lifetime>
  </dictionary>
  ```
- **SQL-синтаксис**:  
  ```sql
  CREATE DICTIONARY ИМЯ_СЛОВАРЯ (АТРИБУТЫ) PRIMARY KEY КЛЮЧ SOURCE(ИСТОЧНИК) LAYOUT(СХЕМА_ХРАНЕНИЯ) LIFETIME(КАК_ЧАСТО_ОБНОВЛЯТЬ)
  ```

#### Ключ словаря
- **Простой ключ**: одно поле, тип всегда `UInt64`.  
  В XML: `<id><name>имя</name></id>`.  
  В SQL: указывается в `PRIMARY KEY`.
- **Составной ключ**: несколько полей с заданными типами.  
  В XML: `<key>несколько полей</key>`, каждое поле описывается как атрибут.  
  В SQL: поля перечисляются в списке и в `PRIMARY KEY`.

#### Атрибуты
- **XML**: описываются внутри `<structure>` как `<attribute>`.
- **SQL**: перечисляются как неключевые поля.

#### Источники данных
1. **Файл на файловой системе**  
   XML: `<file><path>...</path><format>...</format></file>`  
   SQL: `SOURCE(FILE(path './user_files/os.tsv' format 'TabSeparated'))`

2. **Файл по HTTP/HTTPS**  
   XML: `<http><url>...</url><format>...</format></http>`  
   SQL: `SOURCE(HTTP(url '...' format '...'))`

3. **Другие базы данных**  
   - **ODBC**: `SOURCE(ODBC(...))`  
   - **MySQL**: `SOURCE(MYSQL(...))`  
   - **PostgreSQL**: `SOURCE(POSTGRESQL(...))`  
   - **ClickHouse**: `SOURCE(CLICKHOUSE(...))`  
   - **MongoDB**: `SOURCE(MONGODB(...))`  
   - **Redis**: `SOURCE(REDIS(...))`  
   - **Cassandra**: `SOURCE(CASSANDRA(...))`

4. **Исполняемый файл** (указан без деталей)

#### Схема хранения (`layout`)
- **flat**: для простых `UInt64` ключей, параметры `initial_array_size`, `max_array_size`.
- **hashed**: хеш-таблица, эффективнее по памяти.
- **sparse_hashed**: ещё меньше памяти, больше нагрузка на CPU.
- **complex_key_hashed / complex_key_sparse_hashed**: для составных или не-UInt64 ключей.
- **cache**: хранит только часто используемые элементы, параметры: `size_in_cells`, `allow_read_expired_keys` и др.
- **complex_key_cache**: аналогично cache для составных ключей.
- **ssd_cache / complex_key_ssd_cache**: ключи в памяти, значения на SSD.

#### Автообновление (`lifetime`)
- XML: `<lifetime>секунд</lifetime>` или `<lifetime><min>...</min><max>...</max></lifetime>`
- SQL: `LIFETIME(секунд)` или `LIFETIME(MIN секунд MAX секунд)`

#### Обращение к словарю
Функция `dictGet()`:  
```sql
dictGet('dict_name', 'attr_name', key_expr)
```

Пример:  
```sql
SELECT dictGet('prime_numbers_dict', 'is_prime', number_column) AS is_prime
FROM any_table_with_numbers
```

---

## 2. Табличные функции

### Определение
Табличная функция создаёт временную таблицу на лету для выполнения запроса и может использоваться вместо таблицы в секции `FROM`. Некоторые функции позволяют также вставку.

### Популярные табличные функции
- **file(‘путь’, ‘формат’, структура, сжатие)**: создаёт таблицу из файла.
- **fileCluster(cluster_name, ...)**: аналогично `file`, но объединяет файлы с каждой реплики кластера.
- **merge(['db_name'], 'tables_regexp')**: позволяет работать с несколькими таблицами как с единой.
- **url(URL, format, structure, headers)**: аналогично `file`, но загружает данные по HTTP.
- **s3(URL, [ключи], format, structure, compression_method)**: работа с S3.
- **hdfs(URI, format, structure)**: работа с HDFS.
- **remote(addresses_expr, db, table, ...)**: подключение к другим ClickHouse-серверам.
- **cluster / clusterAllReplicas**: работа с кластерами из конфигурации.

---

## 3. Оконные функции

### Определение
Функция, позволяющая вычислять значения относительно диапазона других строк (окна).

### Синтаксис
```sql
agg_func(столбец) OVER (
  PARTITION BY category
  ORDER BY purchases
  ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
)
```
- `PARTITION BY`: определяет независимые окна.
- `ORDER BY`: сортировка внутри окна.
- `ROWS`: диапазон строк (`UNBOUNDED PRECEDING`, `UNBOUNDED FOLLOWING`, `CURRENT ROW`, можно указать количество строк).

### Пример
Вычисление коммулятивной суммы для чётных и нечётных чисел внутри окна, построенного по признаку чётности.

---

## 5. Рефлексия
### Вопросы для самопроверки:
1. Какой layout вы выберете для составного ключа в условиях нехватки оперативной памяти?
2. Что такое «окно» в понятии оконной функции?
