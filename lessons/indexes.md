## Что такое индекс
- Индекс в базах данных — это карта области, где хранятся данные таблицы. В качестве координат используются значения произвольного выражения (чаще всего значения конкретного столбца) для ускорения получения данных по этим координатам.
- Индекс располагается в оперативной памяти, данные — на диске. Могут налагаться требования на уникальность каждой «координаты» или ограничения на кардинальность (количество уникальных значений) в зависимости от устройства и назначения индекса.

## Первичный и вторичный индексы
- **Первичный индекс (основной)** задаётся при создании таблиц, жёстко фиксируется в структуре таблицы и не подлежит изменению. Часто называется «первичный ключ».
- **Вторичные индексы** добавляются и удаляются на уже готовой таблице.

## Первичный индекс в ClickHouse (разреженный minmax индекс)
- Хранит не единичные значения ключевого поля, а минимальное и максимальное значения этого поля на N строк. Последовательность таких строк называется **гранулой**, а N — **гранулярностью** индекса. По умолчанию в ClickHouse размер гранулы — 8192 строк.
- Используется в качестве первичного ключа для таблиц в ClickHouse.
- Допускает неуникальные значения и более 8192 строк (или гранул) одинаковых значений.

### Почему основной индекс в ClickHouse такой?
ClickHouse — аналитическая (OLAP) БД, предназначенная для обработки миллионов/миллиардов строк (объёмы данных — терабайты/петабайты). Классический индекс в таком сценарии расточителен по оперативной памяти и показывает низкую производительность. Разреженный индекс позволяет быстро найти гранулы, содержащие нужные значения, отсеивая ненужные на последующих этапах выполнения запроса.

### Реализация первичного индекса в ClickHouse
- ClickHouse — колоночная БД. Ключом индекса являются min/max значения, а в качестве значения индекса используется `row_id`. Строгий размер гранулы позволяет хранить только её номер, так как `row_id` вычисляются из этого номера.
- Для каждой колонки существует набор «засечек», хранящих адреса на диске для каждой гранулы в колонке.
- Данные при вставке сортируются по основному ключу. Ключ задаётся как последовательный список столбцов: `PRIMARY KEY (column1, column2, ... columnN)` (произвольные выражения не допускаются).
- На каждую вставку создаётся свой набор файлов с индексами и данными (part). Parts в фоновом режиме объединяются (MergeTree) для оптимизации данных, при этом основной ключ пересчитывается заново.
- Разреженный индекс эффективен для больших объёмов данных, но не подходит для поиска регулярными выражениями и проверок на вхождение (для этого существуют вторичные индексы).

### Пример создания таблицы с первичным индексом
```sql
CREATE TABLE regular_table_with_primary_index (
  `index_column1` Date MATERIALIZED toDate(index_column2),
  `index_column2` DateTime,
  `sampling_key` MATERIALIZED toUInt8(index_column2 % 60),
  `data1` String,
  `data2` UInt64
) ENGINE = MergeTree
PARTITION BY index_column1
PRIMARY KEY (index_column1, index_column2, sampling_key)
ORDER BY (index_column1, index_column2, sampling_key)
SAMPLE BY sampling_key
```

## Вторичные индексы в ClickHouse
- Можно добавлять на существующую таблицу для повышения скорости выборки данных.
- Поддерживаемые типы:
    1. **MinMax** — того же вида, что и основной ключ.
    2. **set(N)** — простой и быстрый индекс на все уникальные значения с ограничением на кардинальность (N уникальных ключей на гранулу). При превышении N гранула остаётся неиндексированной.
    3. **bloom filter индексы** (когда ограничения на кардинальность неприемлемы):
        - `bloom_filter` — классический фильтр Блума.
        - `ngrambf_v1` — фильтр Блума по ключам, разбитым на N-частей (фиксированного размера).
        - `tokenbf_v1` — фильтр Блума по токенам (непрерывным цифро-буквенным последовательностям, разделённым не-букво-цифровыми символами).

### Общий синтаксис добавления индекса
```sql
ALTER TABLE [db.]table_name [ON CLUSTER cluster]
ADD INDEX [IF NOT EXISTS] name expression TYPE type [GRANULARITY value] [FIRST|AFTER name]
```
- Индекс можно удалить: `ALTER TABLE ... DROP INDEX`.
- Очистить индекс: `ALTER TABLE ... CLEAR INDEX`.
- После добавления индекс собирается для новых данных. Для существующих данных необходимо выполнить: `ALTER TABLE ... MATERIALIZE INDEX`.

### MinMax как вторичный индекс
- Можно использовать произвольное выражение.
- Не включает сортировку данных по ключу выражения (но можно дополнить ключ сортировки через `ALTER TABLE table MODIFY ORDER BY`, рекомендуется, если ключ аналогичен основному).

### Пример добавления вторичного индекса MinMax
```sql
ALTER TABLE regular_table_with_primary_index_and_secondary_index
ADD column project_id UInt16,
MODIFY ORDER BY (index_column1, index_column2, sampling_key, project_id);

ALTER TABLE regular_table_with_primary_index_and_secondary_index
ADD INDEX minmax_project_id project_id TYPE minmax GRANULARITY 1;

ALTER TABLE regular_table_with_primary_index_and_secondary_index
MATERIALIZE INDEX minmax_project_id;
```

## Использование индексов
### Для чего подходят разные типы индексов?
- **MinMax**: поиск по прямому совпадению (`column == 'value'`), совпадению по маске (`column LIKE '%pattern%'`), лексикографическим и алгебраическим сравнениям (`<`, `>`, `<=`, `>=`, `BETWEEN`).
- **Bloom Filter**: эффективная проверка на вхождение (`column IN ('value1', 'value2')`, `has(array, column)`).
- **ngrambf_v1**: расширяет возможности Bloom Filter полнотекстовым поиском, позволяет использовать регулярные выражения.
- **tokenbf_v1**: аналогично, более эффективен для URL и данных со структурированным логическим разделением не-цифро-буквенными символами, позволяет использовать регулярные выражения.
- **set(N)**: сочетает возможности всех индексов, но только для низкокардинальных данных (не более N уникальных ключей).

### Проверка доступных индексов в таблице
```sql
/* основной ключ */
SELECT primary_key FROM system.tables WHERE table = 'my_table';

/* вторичные индексы */
SELECT type_full, expr FROM system.data_skipping_indices WHERE table = 'my_table';
```
Также можно использовать `SHOW INDEXES FROM table` или `SHOW CREATE TABLE`.

### Выявление потребности во вторичных индексах
1. Изучить секцию `WHERE` запроса.
2. Получить информацию об индексах (как выше).
3. Выявить поля, отсутствующие в основном ключе или обрабатываемые регулярными выражениями.
4. Проверить покрытие полей вторичными индексами.
5. Добавить необходимые вторичные индексы.

**Пример**:  
Запрос с `WHERE match(JSON_payload, '... validation_regex ...')` требует добавления `ngrambf_v1` индекса на поле `json_payload`, если его нет.

## Резюме
- Специальные индексы в колоночных БД ориентированы на анализ больших объёмов данных, работая не с точными значениями, а с диапазонами Min/Max на N строк (гранулы).
- Вторичные индексы покрывают потребности в полнотекстовом поиске и более дешёвой проверке на вхождение с помощью фильтра Блума.

## Рефлексия (вопросы для самопроверки)
1. Что такое индекс?
2. Какой вторичный индекс выбрать для низкокардинальных данных?
3. Приведите пример `WHERE`-секции запроса, для которой недостаточно PRIMARY INDEX.
