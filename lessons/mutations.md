## 1. Манипуляции с партициями

### Партиционирование в MergeTree

Партиционирование в ClickHouse — это способ логического разбиения таблицы на части (партиции) для оптимизации запросов и управления данными.

*   **Оптимизация с помощью Date Column:**
    *   Разбиение по столбцу даты — распространенная стратегия для данных временных рядов.
    *   Позволяет ClickHouse быстро исключать нерелевантные партиции из запросов, фильтрующих по дате, сокращая объем сканируемых данных.
*   **Управление TTL (Time-To-Live):**
    *   Использование столбца даты в выражениях TTL упрощает автоматическую очистку старых данных, поддерживая производительность и эффективность хранения.

### Ключевые особенности

*   **Синтаксис:** `ENGINE = MergeTree … PARTITION BY toYYYYMM(Date)`.
*   Таблица может быть разбита на партиции по любому выражению (по умолчанию — по месяцам).
*   Части данных (parts) из разных партиций никогда не объединяются.
*   Простое управление партициями с помощью команд `ALTER`.
*   Наличие minmax-индекса по столбцам партиционирования.

**Примеры выражений для `PARTITION BY`:**
*   `toYYYYMM(date)`
*   `toMonday(date)`
*   `toYYYYMMDD(date)`
*   `field` (по значению поля)
*   `tuple()` (одна партиция для всех данных)
*   `n % 10`
*   `(toMonday(dt), event)`
*   `if(toUInt8(x), y, z)`

### Команды для работы с партициями

*   **`DROP PARTITION|PART`** – Удаляет партицию или часть.
*   **`DETACH PARTITION|PART`** – Перемещает партицию или часть в директорию `detached` и "забывает" о ней.
*   **`ATTACH PARTITION|PART`** – Добавляет партицию или часть из директории `detached` или из другой таблицы.
*   **`REPLACE PARTITION`** – Копирует партицию из другой таблицы и заменяет существующую (существующие данные теряются).
*   **`FORGET PARTITION`** – Удаляет метаданные пустой партиции из ZooKeeper.
*   **`MOVE PARTITION TO TABLE`** – Перемещает партицию из одной таблицы в другую.
*   **`CLEAR COLUMN IN PARTITION`** – Сбрасывает значение указанного столбца в партиции.
*   **`CLEAR INDEX IN PARTITION`** – Сбрасывает указанный вторичный индекс в партиции.
*   **`FETCH PARTITION|PART`** – Загружает партицию или часть с другого сервера в директорию `detached`.
*   **`MOVE PARTITION|PART`** – Перемещает партицию или часть на другой диск или том.
*   **`UPDATE IN PARTITION`** – Обновляет данные внутри партиции по условию.
*   **`DELETE IN PARTITION`** – Удаляет данные внутри партиции по условию.

### Идентификация и управление

*   **Просмотр информации:** Запрос к системной таблице `system.parts`:
    ```sql
    SELECT database, table, partition, partition_id, name
    FROM system.parts
    WHERE database='default' AND table='ontime'
    ```
*   **Примеры использования:**
    *   `ALTER TABLE ontime DETACH PART '2018_15_26_1'`
    *   `ALTER TABLE ontime DROP PARTITION ID '2018'`

### Hard Links и `ALTER TABLE FREEZE`

*   **Hard Links:** Это механизм файловой системы, позволяющий иметь несколько имен (путей) для одного и того же файла. Hard links работают только в пределах одной файловой системы.
*   **`ALTER TABLE ... FREEZE`:** Создает непротиворечивую (стабильную) локальную копию данных таблицы, используя hard links.
    *   `ALTER TABLE default.ontime FREEZE with NAME 'df02...';`
*   **`ALTER TABLE ... UNFREEZE`:** Удаляет копию данных, созданную командой `FREEZE`.
    *   `ALTER TABLE default.ontime UNFREEZE WITH NAME 'df02...'`

## 2. Мутация данных

### Определение и типы

*   **Мутация** — это операция в ClickHouse, которая изменяет данные в таблице после их вставки.
*   **Типы мутаций:**
    1.  **`UPDATE`** – изменяет существующие строки на основе условия.
    2.  **`DELETE`** – удаляет строки на основе условия.

### Свойства мутаций

*   Не блокируют вставку новых записей.
*   Запущенную мутацию **нельзя откатить**.
*   Мутация продолжается даже после рестарта сервера.
*   Мутацию можно остановить командой `KILL MUTATION`.
*   Записи о завершенных мутациях в `system.mutations` удаляются не сразу (настройка `finished_mutations_to_keep`, по умолчанию 100).
*   Настройка `mutations_sync = 1` заставляет запрос ждать завершения мутации только на текущем узле.
*   **Порядок применения:** Мутации полностью упорядочены по порядку создания и применяются к каждой части данных в этом порядке.
*   **Взаимодействие с `INSERT`:** Данные, вставленные до момента создания мутации, будут изменены; данные, вставленные после — нет.
*   **Немедленный ответ:** Запрос на мутацию возвращается сразу после добавления записи о ней (в ZooKeeper для реплицируемых таблиц или в ФС для нереплицируемых).

### Чем опасны мутации?

*   Выполнение `UPDATE` или `DELETE` приводит к созданию новых "мутированных" версий целых частей данных (parts).
*   Это означает перезапись всех затронутых частей, что вызывает большое количество операций записи и потребление ресурсов.

### Как изменяются данные (на уровне хранения)

*   **Мутация файлов всех столбцов:**
    *   `ALTER TABLE ... DELETE`
    *   `ALTER TABLE ... MATERIALIZE TTL`
*   **Мутация файлов одного или нескольких столбцов:**
    *   `ALTER TABLE ... UPDATE`
    *   `ALTER TABLE ... MATERIALIZE COLUMN`
    *   `ALTER TABLE ... MODIFY COLUMN` (изменение типа данных)
    *   `DELETE FROM ...` (lightweight delete)
*   **Удаление старых и/или создание новых файлов:**
    *   `ALTER TABLE ... MATERIALIZE INDEX/PROJECTION`
    *   `ALTER TABLE ... DROP/RENAME/CLEAR COLUMN`

### Проверка состояния мутации

*   **Просмотр выполняющихся мутаций:**
    ```sql
    SELECT * FROM system.merges WHERE is_mutation
    ```
*   **Просмотр статуса мутаций (незавершенных):**
    ```sql
    SELECT * FROM system.mutations WHERE NOT is_done
    ```
*   **Поиск мутаций, завершившихся ошибкой:**
    ```sql
    SELECT * FROM system.mutations WHERE latest_fail_time > toDateTime(0)
    ```
*   **Принудительная остановка мутации:**
    ```sql
    KILL MUTATION WHERE database='db1' AND table='table1' AND mutation_id='0000000001'
    ```

### Мутации на кластере (`ON CLUSTER`)

*   Статус мутации в таблице `system.mutations` является локальным для каждой реплики.
*   Для проверки статуса на всех узлах кластера необходимо использовать функцию `clusterAllReplicas`:
    ```sql
    SELECT hostname(), * FROM clusterAllReplicas('your_cluster_name', system.mutations);
    ```

### Порядок и параллелизм выполнения

*   **Последовательность и объединение:** ClickHouse выполняет мутации последовательно в рамках одной таблицы, но может объединить несколько мутаций в одну и применить их в одном слиянии. Объединение тысяч мутаций может привести к проблемам из-за чрезмерно сложного выражения.
*   **Параллелизм частей:** Так как данные хранятся в независимых частях (parts), ClickHouse может выполнять слияние мутаций для каждой части параллельно. Это может вызвать высокую нагрузку на ресурсы, особенно память, если мутации содержат подзапросы `IN (SELECT ...)`.
*   **Настройки параллелизма:**
    *   `max_replicated_mutations_in_queue`
    *   `number_of_free_entries_in_pool_to_execute_mutation`
    *   Просмотр настроек: `SELECT * FROM system.merge_tree_settings WHERE name LIKE '%mutation%'`

## 3. Список материалов для изучения (из презентации)

*   `kb.altinity.com/altinity-kb-queries-and-syntax/mutations/#are-mutations-being-run-in-pa rallel-or-they-are-sequential-in-clickhouse-in-scope-of-one-table`
*   `altinity.com/wp-content/uploads/2023/11/ClickHouse-Data-Management-Internals-Mer geTree-Storage-Merges-Replication-2023-11-15.pdf`
*   `clickhouse.com/docs/en/sql-reference/statements/alter/partition#example`
*   `chistadata.com/how-to-avoid-mutations-in-clickhouse/`
```
