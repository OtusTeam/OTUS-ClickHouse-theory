## 1. Виды репликации в различных системах

*   **Синхронная:**
    *   Запрос считается выполненным только после того, как он выполнен на **всех репликах**.
    *   Как правило, все реплики являются лидерами.
    *   Требуются дополнительные механизмы синхронизации.

*   **Асинхронная:**
    *   Запрос считается выполненным после выполнения на принимающей запрос реплике.
    *   Репликация данных на другие реплики происходит в фоновом режиме.
    *   Обычно используется модель "один лидер - несколько реплик", но возможна и мульти-лидерная схема с дополнительными механизмами консистентности.

*   **Подходы к репликации:**
    *   Репликация запросов на выполнение.
    *   Репликация самих данных и их изменений.
    *   Совмещение подходов.

## 2. Репликация в ClickHouse

*   **Тип:** Асинхронная мульти-лидерная.
    *   Каждая реплика самостоятельно принимает данные на запись.
    *   Архитектурно исключены проблемы, типичные для асинхронной репликации.

*   **Принцип работы:**
    1.  Данные о новых кусках данных (партах) записываются в метаданные в **ZooKeeper / ClickHouse Keeper** (далее - *keeper*).
    2.  В очередь *keeper* добавляется событие `GET_PART`.
    3.  Каждая реплика слушает `interserver_http_port` / `interserver_https_port` и анонсирует себя в *keeper.
    4.  Реплики разбирают очередь и выполняют `GET_PART`, скачивая недостающие парты с соседних реплик.
    *   Отсутствуют требования к уникальности `Primary Key` (нет автоинкремента).

*   **Тип репликации:** Mixed (смешанный).
    *   Для данных - аналог **ROW** (партионный, PART-Based).
    *   Для метаданных и мутаций - аналог **Statement**.

*   **Необходимые условия для настройки:**
    1.  Секция `<zookeeper>...</zookeeper>` в конфигурации, указывающая на рабочий кластер *keeper.
    2.  Использование движка таблицы с приставкой `Replicated` (например, `ReplicatedMergeTree`).
    3.  Дополнительные параметры движка:
        *   `path` - путь в *keeper для таблицы (должен быть уникальным для каждой таблицы).
        *   `replica` - уникальное имя реплики.
    4.  Уникальный путь в *keeper для каждой таблицы.

*   **Пример конфигурации и создания таблицы:**
    ```xml
    <zookeeper>
        <node index="1"><host>zk-server1.zone</host><port>2181</port></node>
        <node index="2"><host>zk-server2.zone</host><port>2181</port></node>
        <node index="3"><host>zk-server3.zone</host><port>2181</port></node>
    </zookeeper>
    ```
    ```sql
    CREATE TABLE replication_test (
        `a` String
    ) ENGINE = ReplicatedMergeTree('/some_uniq_zookeeper_path', 'some_replica_name')
    ORDER BY a;
    ```

*   **Макросы:**
    *   Применяются для упрощения задания параметров репликации.
    *   Определяются в конфигурации: `<macros><macro_name>value</macro_name></macros>`.
    *   Часто используемые: `<shard>`, `<replica>`, `<host>`.
    *   Встроенные макросы: `<database>`, `<table>`.
    *   Пример использования:
        ```sql
        CREATE TABLE ... ENGINE = ReplicatedMergeTree('/clickhouse/shard_{shard}/{database}/{table}', '{replica}', ...);
        ```

*   **Добавление новой реплики:**
    1.  Развернуть новый сервер с идентичной конфигурацией ClickHouse (кроме секции `<macros>` и параметров идентификации сервера, например, `interserver_host`).
    2.  Создать все таблицы, как на соседней реплике, с теми же `path` в *keeper, но с уникальным значением параметра `replica`.
    3.  ClickHouse автоматически выкачает все данные по репликации.

*   **Конвертация обычной таблицы в реплицируемую:**
    1.  Создать новую реплицируемую таблицу с тем же набором колонок: `CREATE TABLE new AS old ENGINE=Replicated*(...)`.
    2.  Перенести данные из старой таблицы в новую по частям:
        *   Найти все `partition_id`: `SELECT DISTINCT partition_id FROM system.parts WHERE table = 'old'`.
        *   Выполнить для каждой партиции: `ALTER TABLE new ATTACH PARTITION ID '...' FROM old`.
    3.  Заменить старую таблицу новой: `EXCHANGE TABLES new AND old; DROP TABLE new;` или `DROP TABLE old; RENAME TABLE new TO old;`.

*   **Роль лидера:**
    *   Лидер назначает операции слияния партов (`MERGE_PARTS`).
    *   Поведение можно регулировать настройкой `can_become_leader`.
    *   В зависимости от версии ClickHouse может быть несколько лидеров или все реплики могут ими быть.

*   **Скорость репликации:**
    *   Очень высокая, данные передаются без сжатия и дообработки (только подсчет контрольных сумм).
    *   Узкие места: скорость дисковой системы, перегруженный *keeper (при частых мелких батчах).
    *   Может утилизировать весь доступный сетевой канал.
    *   **Ограничение скорости:**
        *   `max_replicated_sends_network_bandwidth_for_server` (предпочтительно)
        *   `max_replicated_fetches_network_bandwidth_for_server`

*   **Мониторинг состояния репликации:**
    *   **`system.replicas`**: состояние репликации для каждой таблицы.
        *   `is_readonly`: `0` - все хорошо, `1` - репликация не работает (таблица заблокирована на запись).
        *   `last_queue_update_exception`, `zookeeper_exception`: информация об ошибках.
        *   `absolute_delay`, `queue_size`, `{inserts,merges,part_mutations}_in_queue`: лаг и состояние очередей.
        *   `{total,active}_replicas`, `replica_is_active`: информация о репликах в кластере.
    *   **`system.replication_queue`**: состояние очереди событий репликации.
        *   `type`: тип события (`GET_PART`, `REPLACE_RANGE`, `MERGE_PARTS` и т.д.).
        *   `postpone_reason`: причина откладывания события (например, "Not executing fetch ... because 8 fetches already executing" - это нормально).
        *   `num_postponed`: сколько раз событие откладывалось.
        *   `num_tries`, `last_exception`: количество попыток и причина последней ошибки.

## 3. TTL (Time-To-Live) - отложенное удаление данных

*   **Назначение:** Автоматическое удаление устаревших данных или перемещение их между дисками (горячее/холодное хранение).

*   **Синтаксис объявления:**
    *   **Для столбца:** `CREATE TABLE table ( ... column Тип TTL timestamp + INTERVAL 1 hour ... )`
    *   **Для таблицы (строки):** `CREATE TABLE table ( ... ) ... TTL timestamp + INTERVAL 1 hour`
        *   `timestamp` - колонка типа `Date` или `DateTime`.
        *   `INTERVAL 1 hour` - интервал времени.

*   **Перемещение данных (при наличии `storage_policy`):**
    *   `TTL timestamp + INTERVAL 1 hour TO VOLUME 'volume_name_from_config'` (объявляется на уровне таблицы).

*   **Важные особенности:**
    *   Сравнение с TTL происходит **во время слияния партов (`Merge`)**.
    *   Операция потребляет ресурсы (сравнение `timestamp` для каждой строки).
    *   В высоконагруженных системах слияние может произойти значительно позже наступления TTL или не произойти вовсе (при достижении максимального размера парта).
    *   **Альтернатива и рекомендация:**
        *   Настройка `ttl_only_drop_parts` меняет поведение на удаление целых партов.
        *   Более надежным и эффективным способом является использование `cron` с командами `ALTER TABLE DROP PARTITION` или `ALTER TABLE MOVE PARTITION`.

## 4. Mutations (Мутации)

*   Это фоновые операции изменения данных (например, `UPDATE`, `DELETE`).
*   Статус выполнения мутаций отслеживается в таблице **`system.mutations`**.
    *   `command`: запрос, описывающий мутацию.
    *   `is_done`: `=1` когда мутация успешно выполнена.
    *   `latest_fail_reason`: информация о последней ошибке.
    *   `parts_to_do_names` / `parts_to_do`: прогресс выполнения (сколько партов осталось обработать).

## 5. Merge операции (Слияния)

*   **Назначение:** Объединение мелких партов данных в более крупные для оптимизации хранения и запросов.

*   **Алгоритмы слияния:**
    1.  **Horizontal (по умолчанию):** Выбирает для слияния столько партов, сколько позволяет настройка `max_bytes_to_merge_at_max_space_in_pool` (по умолчанию 150 ГБ).
    2.  **Vertical:** Выбирает строго 2 парта для слияния. Включается автоматически при достижении одного из критериев:
        *   `vertical_merge_algorithm_min_rows_to_activate = 131072`
        *   `vertical_merge_algorithm_min_bytes_to_activate = inf` (по умолчанию)
        *   `vertical_merge_algorithm_min_columns_to_activate = 11` (для столбцов, не входящих в ключ)

*   **Типы Merge-операций:**
    *   `MERGE_PARTS` (основное слияние)
    *   `MUTATE_PART` (слияние в рамках мутации)
    *   `GET_PART` (скачивание парта)
    *   `REPLACE_RANGE` (замена диапазона партов)
    *   `TTL_MERGE` (слияние, вызванное TTL)

## 6. Выделение ресурсов под фоновые операции (Пулы потоков)

Количество одновременных фоновых задач определяется размерами пулов потоков. Актуальный список можно получить запросом:
```sql
SELECT * FROM system.metrics WHERE metric LIKE 'Background%'
```

*   **`background_pool_size` (default: 16):** Потоки для операций `Merge` и мутаций.
*   **`background_move_pool_size` (default: 8):** Пул для операций `MOVE_PART`.
*   **`background_fetches_pool_size` (default: 16):** Пул для операций `GET_PART`.

*   **Примечание:** В старых версиях настройки выставляются пользователем, в новых — в основной конфиг сервера. Состав и назначение пулов могут меняться от версии к версии. Чаще всего ресурсов не хватает TTL-операциям.

## Вопросы для самопроверки:
1.  Как добавить реплику?
2.  Как настроить удаление данных старше 7 дней для таблицы с партиционированием по столбцу `date` типа `Date`?
3.  ClickHouse утилизирует всю пропускную способность сервера, создавая проблемы для других приложений. Какие следует принять меры?
```
